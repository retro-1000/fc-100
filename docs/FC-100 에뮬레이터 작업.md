금성(GOLDSTAR) 패미콤 FC-100
금성사(현 LG전자) 패미콤 FC-100에 대한 자료를 모아두는 곳입니다. * 닌텐도 패미콤에 대한 자료는 없습니다.

2013년 1월 27일 일요일
FC-100 에뮬레이터 작업
FC-100은 PHC-25와 유사하다고 합니다.

그래서 PHC-25용 에뮬레이터를 만드는 일본사람의 소스를 수정해서 작업을 시작했습니다.

저도 몇년전에 한번 해볼까 말까 하다가 우연히 국내에서도 저와 관심이 비슷한 분을 발견하고 그분하고 협업을 하려고 시작했습니다.

그분의 블로그(진스맥 이라는 분이네요)는 여기를 클릭하세요
글을 쓰는 이 시점에 그분하고 연락은 안되었습니다.

우선 PHC-25용 소스를 받아야 합니다.
http://homepage3.nifty.com/takeda-toshiya/

"Common Source Code Project"를 클릭하셔서 소스를 받습니다.

그리고 PHC-25용의 설정 폴더를 복사한뒤 작업을 시작합니다.
컴파일 하려면 XP용 DirectX SDK가 있어야 합니다.
XP DirectX SDK

PHC-25의 memory.cpp의 내용을 수정합니다.
제 기억에 FC-100은 0x8000부터 RAM으로 인식하는것으로 기억합니다.
그래서 아래와 같이 수정하였습니다.

<code>
 // set memory map
#ifdef _MAP1010
 SET_BANK(0x0000, 0x5fff, wdmy, rom );
 SET_BANK(0x6000, 0x77ff, vram, vram);
 SET_BANK(0x7800, 0x7fff, wdmy, rdmy);
 SET_BANK(0x8000, 0xffff, ram,  ram );
#else
 SET_BANK(0x0000, 0x5fff, wdmy, rom );
 SET_BANK(0x6000, 0x77ff, vram, vram);
 SET_BANK(0x7800, 0x7fff, wdmy, rdmy);
 SET_BANK(0x8000, 0xffff, ram,  ram );
#endif
</code>

그리고 나서 얻은 화면이 다음과 같습니다.
![image](https://github.com/user-attachments/assets/55fb5eff-1363-49cb-a828-80de857a7555)


여기까지는 금방이라서 감격을 했습니다.

근데 실행이 안되는 이유를 찾아보려고 하다가 아래와 같은 치명적인 부분을 발견했습니다.
이후에 설명할 디스어셈블과 HEX 리스팅 파일은 여기를 참고하여 주세요

FC-100과 PHC-25는 모두 Z80 인터럽트 모드1을 사용합니다.
인터럽트 모드 1에서는 하드웨어 인터럽트가 발생하면 0038H번지로 점프합니다.
그런데 FC-100의 인터럽트 벡터의 내용은 아래와 같은것으로 채워져있습니다.

0038 CD05FB    CALL    0FB05H

아악~~~
이것의 의미는 좀 복잡합니다.
PHC-25 에뮬레이터에서 저 주소는 그냥 램의 주소입니다.

FC-100에서도 RAM번지인 저곳으로 뛰었다면 세가지 중에 하나입니다.
1. 부트스트래퍼에서 FB05H에 롬 프로그램 일부를 복사한다.
2. FxxxH 번지 일부가 하위의 롬에 중복매핑되어 있다.
3. 페이징을 사용하는 메커니즘이 있고 그래서 FB05H로 뛰었다.

FC-100의 모든것이라는 기고문을 통해서 FB05가 인터럽트 1번의 후크주소임이 밝혀졌습니다.
이에 따라 메모리 배치를 다시해볼 생각입니다.

원래 Z80같은 8비트류의 직접어드레싱 가능한 최대 메모리는 64KBytes입니다.
따라서 메모리 확장을 위해서 페이징방식을 사용하는데요.
FC-100의 부트스트래퍼를 전부 따라가 본것은 아니지만 아무래도 페이징 방식인것 같은 느낌입니다.
부트 벡터의 내용은 아래와 같은데

<code>
0000 F3        DI      
0001 C38919    JP      1989H
</code>

1989번지의 내용은 아래와 같습니다.

<code>
1989 F3        DI      
198a 3100E0    LD      SP,0E000H  <- 스택 상위 주소
198d ED56      IM      1              <- 인터럽트 모드 1 설정
198f D371      OUT     (71H),A    <- 페이징 제어를 하는 부분으로 추정
1991 D360      OUT     (60H),A   <- 페이징 제어를 하는 부분으로 추정
1993 210078    LD      HL,7800H
1996 1100E0    LD      DE,0E000H
1999 010008    LD      BC,0800H
199c D5        PUSH    DE
199d E5        PUSH    HL
199e C5        PUSH    BC
199f EDB0      LDIR    
19a1 C1        POP     BC
19a2 D1        POP     DE
19a3 E1        POP     HL
19a4 D371      OUT     (71H),A   <- 페이징 제어를 하는 부분으로 추정
19a6 D361      OUT     (61H),A   <- 페이징 제어를 하는 부분으로 추정
19a8 EDB0      LDIR    
19aa D370      OUT     (70H),A   <- 페이징 제어를 하는 부분으로 추정
19ac 2100FA    LD      HL,0FA00H  <- FB05영역을 포함하여 0으로 채우는 루틴 시작
19af 1101FA    LD      DE,0FA01H
19b2 01A201    LD      BC,01A2H
19b5 3600      LD      (HL),00H
19b7 EDB0      LDIR              <- FB05영역을 포함하여 0으로 채우는 루틴 끝
19b9 210080    LD      HL,8000H
19bc 7E        LD      A,(HL)
19bd 2F        CPL     
19be 77        LD      (HL),A
19bf BE        CP      (HL)
19c0 210080    LD      HL,8000H
19c3 2803      JR      Z,19C8H          ; (+03H)
19c5 2100C4    LD      HL,0C400H
19c8 2200C4    LD      (0C400H),HL
</code>
이 자료를 볼 때 메모리 페이징을 사용할 가능성이 높습니다.
FC-100에 대한 자료중에 페이징을 어떻게 했는지에 대한 자료를 구하지 못하면 PHC-25에뮬레이터를 조금 손보는 정도로는 FC-100 에뮬레이터를 만들지 못합니다.

앞서 FC-100 에뮬레이터를 시작하신 분께서 손수 회로도를 그리시는것 같은데
그것이 어느정도 완성되면 알수 있게될것 같습니다.

저도 예전 자료를 한번 찾아보도록 하겠습니다.
오늘은 여기까지 입니다.

2013년 1월 30일
FC-100의 모든것이라는 마소기사를 참고하여 메모리 맵을 조정하였습니다.
작동은 하는것 같긴한데 키보드 매핑을 알수가 없네요.
![image](https://github.com/user-attachments/assets/447f2623-fbd3-42e0-aeac-b330e74a3c19)


키보드 매핑을 알기위해 디스어셈블을 볼지 아니면 다른자료를 찾아볼지 고민중입니다.
쩝쩝....
일단 저런 화면이라도 나와서 엄청 기쁩니다.

2013년 1월 31일
키보드가 작동하는게 아니였습니다.
8251초기화를 해줘야만 키보드 스캔을 시작하더군요.
쉽지 않네요.......
일단 8251초기화를 한뒤 키보드 값은 안맞지만 대충 키보드가 먹는 상태까지입니다.<br/>
![image](https://github.com/user-attachments/assets/696dde9b-c984-48d3-ad6f-942ceb783b98)


2013년 2월 15일
작업을 한것은 아니구요~~
설날에 고향집에 가서 작업하려고 했는데, 제 노트북이 고장이어서 작업을 못했습니다.
대신 금성사의 "컴퓨터 패밀리" 월간지를 들고 왔는데 한번보시죠.
컴퓨터 패밀리

2013년 2월 26일(새벽)
컴퓨터가 복구되어서 작업을 시작해봤습니다.
Win8 빠르고 좋군요...
키스캔 코드값을 알아내기 위해서 IO 0x00번지부터 0x0f 번지까지 각 1비트마다 값을 바꿔보면서 화면상에 나타나는 문자값을 얻었습니다.
0x00에서 0x0f까지의 내용중에 상위니블에는 매핑된 키값이 없는것 같습니다.
하위 니블에는 키값이 대부부니 매핑되어 있습니다.

"따~~따따따"하는 키음이 들리면 일단 키가 있는것으로 봤구요.
화면상에 문자가 표시되지 않은 키는 ??로 표시했습니다.
그렇지 않은것은 키가 매핑되지 않은것으로 봤습니다.
매핑되지 않은키는 xx로 했습니다.
현재까지는 방향키다 쉬프트키 까지는 알 수 없습니다.

<code>
  7 6 5 4 3 2 1 0
 00: xx xx xx xx [ ] p o
 01:    xx \ BS = RET
 02:     ?? ?? ?? xx
 03:     9 ; ' ??
 04:     5 6 7 8
 05:     1 2 3 4
 06:     F5 xx RUN 0
 07:     F1 F2 F3 F4
 08:     - / . ,
 09:     ?? ?? xx ??
 0A:     b n m l
 0B:     z x c v
 0C:     g h j k
 0D:     a s d f
 0E:     t y u i
 0F:     q w e r
</code>
이 값을 찾는데 무려 100회 이상 컴파일/실행을 반복했습니다.
아직 확실한것은 아닙니다.
곧 키보드 입력이 가능할것 같습니다.

2013년 2월 26일(저녁)
키코드값을 넣고나서 쉬프트 키와 CAPSLOCK키 컨트롤키의 매핑을 알아냈습니다.
키스캔 IO번지내용의 상위 니블이 CAPSLOCK과 쉬프트키, CTRL 키였습니다.

나머지 하나도 어떤키는 읽혀 지는데 아마도 한글키 같습니다.

한글키는 어떤거였는지도 잘 모르겠구요..
스페이스 좌우에 있는 금성키와 아무것도 없는키중에 하나였던것 같은데..


또 ESC키가 어떤기능이었는지 생각이 안나네요.
ESC키로 생각되는 키가 어떻게 확인해야 하는지 잘모르겠어요.

어쨋든 키매핑을 하고 나니 프로그램 입력이 가능해졌습니다.
지금 상태에서는 실행속도는 엄청느립니다.

첫번째 프로그램은 변수 A,B를 읽어서 덧셈을 해주는 프로그램이고
두번째 프로그램은 1부터 1000까지 더하는 프로그램이죠
옛날생각이 새록새록.. ㅋㅋㅋ

MC6847관련해서 메모리 매핑을 좀더 신경써봐야 할것 같습니다.
커서를 나오게 해야할텐데..
현재는 커서가 안나옵니다.
![image](https://github.com/user-attachments/assets/3ece85ae-6fed-4a28-85fa-0b829a66156f)

![image](https://github.com/user-attachments/assets/6e1b6a35-e4e3-4a2a-891f-84a003c9727e)



다음은 CHR$(0-255)까지 찍는 프로그램이죠.

<code>
10 FOR I=0 TO 255
20 PRINT CHR$(I);
30 NEXT I
RUN</code>

![image](https://github.com/user-attachments/assets/c5b18867-5a50-4b1e-887f-508aa6cb3fbe)





2013년 3월 2일#1
심심해서 FC-100에 대한 자료를 찾다가 네이버 카페에서 에뮬레이터를 만드신분을 찾았습니다.
그분도 제 블로그의 롬파일을 사용하셨더군요 ㅎㅎㅎ.
진스맥님, 제니님, bluemsx님도 비슷한 작업을 하십니다.
저는 공동작업을 제안하고 싶어요...

제 블로그의 롬파일은 카세트 레코더로 추출한것이 아니고
실기에서 뽑아서 롬라이터로 읽은 것입니다.
롬라이터로 읽더라도 오류가 날 수 있기 때문에 롬을 다시 빼고 끼운 다음 다시 읽는 작업을 몇번을 반복해서 내용이 같은 것을 확인한것입니다.
제 FC-100 실기는 전원쪽에 문제가 있어서 작동하지 않습니다.
그래서 롬파일의 체크섬은 실기에서 확인할 수는 없어요.

많은분 께서 작업하시니 곧 FC-100 에뮬레이터가 세상에 나올 수 있을것 같네요.
그런데.. 좀 아쉬운것은 FC-100은 소프트웨어가 거의 없다는거예요.
에뮬레이터를 만들고나서도 그위에 돌려볼 소프트웨어가 없어요.
그저 저처럼 1에서 100더하기나 짜보거나 라인그리기나 해보거나 그정도..
이걸로 뭔가 해볼게 없을까요?

2013년 3월 2일#2
bluemsx님으로부터 VDG내장 폰트에 대한 확인 요청이 있었습니다.

<code>5 SCREEN1,1,1:CLS
10 FORI=32TO255:PRINT CHR$(I);:NEXT
20 FORI=32TO255:POKE &HC000+I-32,0:NEXT
</code>
![image](https://github.com/user-attachments/assets/dd70ce05-e543-4ce3-ac77-7c5c11577a08)

이 프로그램의 실행결과는 아래와 같습니다.
그 의미는 bluemsx님께서 확인해주실 것입니다.

![image](https://github.com/user-attachments/assets/f1565360-d88e-4289-a2d5-e2042409854a)
![image](https://github.com/user-attachments/assets/ab501016-da0e-4d56-a87c-7632fdd5d16e)


bluemsx님께서 쪽지를 통해 연락을 주셨습니다.
위 프로그램은 6847내장 폰트를 출력하는 프로그램이라는군요.
같은 6847을 사용한 PC-6001에서는 아래와 같이 출력된다고 합니다.
![image](https://github.com/user-attachments/assets/db5f8412-6d6c-4123-8589-c822ebcd4c59)


FC-100에서 6847운영은 메모리 페이지를 사용하기 때문에 관련루틴을 업데이트하면 결과가 어떨지 잘 모르겠습니다.

실기에서의 결과가 궁금합니다.

10 SCREEN 1,1,1:CLS
20 FOR I=0 TO 255
30 POKE &HC000+I,I:NEXT
40 IF INKEY$="" THEN 40

이 프로그램을 실행하면 나오는 내용인것 같습니다. 이 프로그램은 bluemsx님께서 알려주셨습니다.

2013년 3월 3일
하루 이틀사이에 갑자기 FC-100 에뮬레이터가 완성이 되어 버렸습니다.
주된 작업을 하신분은 네이버에서 활동중이신 재니님입니다.
그분의 페이지는 다음과 같습니다.
http://cafe.naver.com/myspc/259?social=1
연휴동안에 초 고속 스피드로 작업하신것 같아요.

제가 스스로 해보고 싶었던 일이었는데, 스스로 좀 아쉽기도 하고, 재니님께 고맙기도 합니다.

FC-100에 추억을 가지신 분들의 기억을 조금씩 쌓을 수 있는 기반이 마련된것 같아 매우 기쁘고요..

재니님과 bluemsx님과 제가 공동작업환경을 마련하는 중이었어요.
공동 작업환경이 구축되면 좀더 많은 자료로 찾아뵐수 있을것 같습니다.

2013년 3월 9일
다께다 토시야씨로 부터 본 프로젝트를 위해 소스코드를 사용하는것을 허락맞고나서, 공동작업을 하기위해 구글 코드에 프로젝트를 만들었습니다.

https://code.google.com/p/fc-100/

최초에는 제가 마지막 작업한 코드를 커밋해 두었습니다.
방금 컴파일을 해봤는데 컴파일은 되는군요.
제가 작업한 부분까지는 같이 시험해보실 수 있으십니다.
이번 주말을 통해서 재니님과 bluemsx님께서 참여하여 주실것입니다.
재니님은 이미 데이터레코드에 대한 작업계획을 가지고 계시더군요..
역시 재니님...
본 에뮬레이터 페이지는 그 작업환경에 대한 관리적인 측면의 내용을 다루게 될것입니다.
그 이외에 참여를 원하시는 분이 있으시면 연락을 주시면 좋겠습니다.

작성자: FreeFix 시간: 오후 4:23 
이메일로 전송
BlogThis!
Twitter에서 공유
Facebook에서 공유
Pinterest에 공유
라벨: 금성 패미콤, 에뮬레이터, FC-100, Z-80, Z80
